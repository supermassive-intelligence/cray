#!/usr/bin/env bash
# This script was generated by bashly 1.2.2 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
cray_usage() {
  printf "cray - Cray CLI\n\n"

  printf "%s\n" "Usage:"
  printf "  cray COMMAND\n"
  printf "  cray [COMMAND] --help | -h\n"
  printf "  cray --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Build image from dockerfile\n" "build-image"
  printf "  %s   Start the container\n" "up         "
  printf "  %s   Run tests in the container\n" "test       "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
cray_build_image_usage() {
  printf "cray build-image - Build image from dockerfile\n\n"

  printf "%s\n" "Usage:"
  printf "  cray build-image\n"
  printf "  cray build-image --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
cray_up_usage() {
  printf "cray up - Start the container\n\n"

  printf "%s\n" "Usage:"
  printf "  cray up\n"
  printf "  cray up --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
cray_test_usage() {
  printf "cray test - Run tests in the container\n\n"

  printf "%s\n" "Usage:"
  printf "  cray test [TEST-PATH] [OPTIONS]\n"
  printf "  cray test --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--coverage-path COVERAGE-PATH"
    printf "    Absolute path to a directory to write coverage results into\n"
    printf "    %s\n" "Default: /tmp/cray/coverage"
    echo

    # :flag.usage
    printf "  %s\n" "--verbose VERBOSE"
    printf "    Prints out DEBUG logs as the test is running.\n"
    printf "    %s\n" "Allowed: yes, no"
    printf "    %s\n" "Default: no"
    echo

    # :flag.usage
    printf "  %s\n" "--workers WORKERS"
    printf "    Number of workers, default is auto\n"
    printf "    %s\n" "Default: auto"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TEST-PATH"
    printf "    Relative path to the directory or file with test cases\n"
    printf "    %s\n" "Default: test/infra/*"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# cmd/lib/colors.sh
print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

# :command.command_functions
# :command.function
cray_build_image_command() {
  # cmd/build_image_command.sh
  inspect_args

  docker build -t cray:latest --shm-size=8g .

  echo $(green_bold Successfully built image)

}

# :command.function
cray_up_command() {
  # cmd/up_command.sh
  #inspect_args

  docker compose -f docker-compose.yaml up --build

}

# :command.function
cray_test_command() {
  # cmd/test_command.sh
  inspect_args

  test_path=${args[test-path]}
  tag=${args[--tag]}
  verbose=${args[--verbose]}
  workers=${args[--workers]}

  if [ -z "$tag" ]; then
    tag="cray:latest"
  fi

  ./cray build-image

  declare -a start_slurm_command_parts

  start_slurm_command_parts=(
      "./scripts/start_slurm.sh" ";"
  )

  declare -a pytest_command_parts
  pytest_command_parts=(
        "${start_slurm_command_parts[*]}"
        "python" "-m" "pytest" "-rF" "--dist=loadgroup" "--color=yes"
        "--durations=10" "--durations-min=10.0" "--forked" "--verbose" "-vv"
        "-o" "log_cli=true" "-o" "log_cli_level=DEBUG")

  if [ "yes" == "$verbose" ]; then
    pytest_command_parts+=("-rP")
  fi

  pytest_command_parts+=($test_path)
  pytest_command="${pytest_command_parts[*]}"

  TTY=-t
  if test -t 0; then
    TTY=-it
  fi

  echo "Test path: $test_path"
  echo $command
  echo $tag

  # Remove the trailing * from the test path, if it exists
  base_test_path=${test_path%\*}

  if [ ! -e $base_test_path ]; then
    echo $(red_bold "File or does directory exists:  $base_test_path")
    exit 1
  fi

  declare -a docker_command_parts

  docker_command_parts=("docker" "run" "--rm" "--init" )

  docker_command_parts+=("-e" "PY_FORCE_COLOR=1"
              "-e" "PY_COLORS=1"
              "-e" "FORCE_COLOR=1"
              "$TTY" "$tag" "sh" "-c" "'$pytest_command'")

  docker_command="${docker_command_parts[*]}"
  echo $docker_command
  eval $docker_command

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        cray_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    build-image)
      action="build-image"
      shift
      cray_build_image_parse_requirements "$@"
      shift $#
      ;;

    up)
      action="up"
      shift
      cray_up_parse_requirements "$@"
      shift $#
      ;;

    test)
      action="test"
      shift
      cray_test_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      cray_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
cray_build_image_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        cray_build_image_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="build-image"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
cray_up_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        cray_up_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="up"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
cray_test_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        cray_test_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="test"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --coverage-path)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--coverage-path']="$2"
          shift
          shift
        else
          printf "%s\n" "--coverage-path requires an argument: --coverage-path COVERAGE-PATH" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --verbose)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--verbose']="$2"
          shift
          shift
        else
          printf "%s\n" "--verbose requires an argument: --verbose VERBOSE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --workers)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--workers']="$2"
          shift
          shift
        else
          printf "%s\n" "--workers requires an argument: --workers WORKERS" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['test-path']+x} ]]; then
          args['test-path']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['test-path']:-} ]] || args['test-path']="test/infra/*"
  [[ -n ${args['--coverage-path']:-} ]] || args['--coverage-path']="/tmp/cray/coverage"
  [[ -n ${args['--verbose']:-} ]] || args['--verbose']="no"
  [[ -n ${args['--workers']:-} ]] || args['--workers']="auto"

  # :command.whitelist_filter
  if [[ ${args['--verbose']:-} ]] && [[ ! ${args['--verbose']:-} =~ ^(yes|no)$ ]]; then
    printf "%s\n" "--verbose must be one of: yes, no" >&2
    exit 1
  fi

}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  set -e

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a env_var_names=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "build-image") cray_build_image_command ;;
    "up") cray_up_command ;;
    "test") cray_test_command ;;
  esac
}

initialize
run "$@"
